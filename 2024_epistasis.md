# Epistasis

One interesting way to explore the genomic data is to look for regions within the SL region that together have an interaction on sex. If the sites are called 'g1' and 'g2' the relationship we are testing is sex ~ g1*g2.

I first developed a script that transformed a vcftools-generated tab-delimited file to a different format with one letter for each genotype:
```
#!/usr/bin/env perl
use strict;
use warnings;
use lib qw(~/perl_modules);
use List::MoreUtils qw/ uniq /;

# Prepare input file
# module load tabix
# bgzip -c file.vcf > file.vcf.gz
# tabix -p vcf file.vcf.gz
#  Now use vcftools to make a tab delimited file:
# module load StdEnv/2020 vcftools/0.1.16
# zcat file.vcf.gz | vcf-to-tab > out.tab

# on computecanada:
# module load perl/5.30.2
# module load gcc/9.3.0
# cpan
# install List::MoreUtils

#  This program reads in a tab delimited genotype file generated by vcftools (vcf2tab) 
#  and makes a one letter tab-delimited genotype file for analysis with another perl script called
#  Parse_tab_XT_epistasis.pl

#  If there are not genotypic data from at least one male and one female, the genotypes
#  for that site will not be printed to file

# to execute type Make_oneletter_genotypes_from_tab.pl inputfile.tab 11111110000002222122 outputfile.tab 
# where 11111110000002222122 refers to whether or not each individual in the ingroup 
# in the vcf file is (0) male, (1) female, and or (2) skipped

# 11111110000002222122 ignores tads, mell, and cal

# this can be further subsetted like this:
# awk 'NR % 5 == 0' input > output
# I think 5000 lines is about the maximum that can be processed in a reasonable amount of time.


my $inputfile = $ARGV[0];
my $input2 = $ARGV[1];
my $outputfile = $ARGV[2];

unless (open DATAINPUT, $inputfile) {
	print "Can not find the input file.\n";
	exit;
}

unless (open(OUTFILE, ">$outputfile"))  {
	print "I can\'t write to $outputfile\n";
	exit;
}
print "Creating output file: $outputfile\n";

my @sexes = split("",$ARGV[1]);
my @males=();
my @females=();
my @MFcombined=();
my @temp;
my @unique_male_nucleotides;
my @unique_female_nucleotides;
my @unique_MFcombined_nucleotides;
my $y;
my $x;
my $counter=0;
my $diverged=0;
my $diverged_2=0;
my $number_of_male_individuals_genotyped=0;
my $number_of_female_individuals_genotyped=0;
my @male_specific_nucleotides=();
my $male_het_nuc1=0;
my $male_het_nuc2=0;
my $female_hom_nuc1=0;
my %unque_genotypes;
my @letter_genotypes = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z);

for ($y = 0 ; $y <= $#sexes ; $y++ ) {
	if($sexes[$y] == 0){
		$number_of_male_individuals_genotyped +=1;
	}	
}	
for ($y = 0 ; $y <= $#sexes ; $y++ ) {
	if($sexes[$y] == 1){
		$number_of_female_individuals_genotyped +=1;
	}	
}
print "This includes ",$number_of_female_individuals_genotyped," female(s) and  ", $number_of_male_individuals_genotyped," males\n";

while ( my $line = <DATAINPUT>) {
	chomp($line);
	@temp=split /[\t\/]/,$line;
	if($temp[0] ne '#CHROM'){
		if($#temp ne (($#sexes+1)*2)+2){
			print "The number of individuals in the input line does not match the number of individuals genotyped ",
			$temp[0],"\t",$temp[1],"\t",$#temp," ",(($#sexes+1)*2)+2,"\n";
		}
		# parse the bases in all genotypes in each sex
		@males=();
		@females=();
		@MFcombined=();
		$counter=0;
		for ($y = 3 ; $y <= $#temp; $y=$y+2 ) {
			if(($temp[$y] ne ".")&&($temp[$y+1] ne ".")&&($temp[$y] ne "*")&&($temp[$y+1] ne "*")){ # no missing, no deletions
				if($sexes[$counter] == 0){
						push(@males, $temp[$y]);
						push(@males, $temp[$y+1]);
				}
				elsif($sexes[$counter] == 1){
					push(@females, $temp[$y]);
					push(@females, $temp[$y+1]);
				}
				push(@MFcombined, $temp[$y]);	
				push(@MFcombined, $temp[$y+1]);	
			}
			$counter+=1;
		}	
		# OK I should have all the bases loaded for non-missing genotypes for each male and each female
		# and combined as well	
		# find out what and how many unique nucleotides are in each sex
		@unique_male_nucleotides = uniq @males;
		@unique_female_nucleotides = uniq @females;
		# find out how many unique nucleotides there are in the combined genotypes
		@unique_MFcombined_nucleotides = uniq @MFcombined;
		# print $#unique_female_nucleotides," ",$#unique_male_nucleotides,"\n";
		if(($#unique_male_nucleotides != -1)&&($#unique_female_nucleotides != -1)&&
		($#males == ($number_of_male_individuals_genotyped*2-1))&&
		($#females == ($number_of_female_individuals_genotyped*2-1))){
			# this means that there are no missing genotypes for both sexes
			# we can calculate the pvalue because both sexes have data
			# First make an array for males and females with recoded genotypes
			# define all possible pairwise combinations of genotypes
			# in either order, eg A/T or T/A are the same
			%unque_genotypes=();
			$counter=0;
			for ($y = 0 ; $y <= $#unique_MFcombined_nucleotides; $y++ ) {
				for ($x = 0 ; $x <= $y; $x++ ) {
					#print $unique_MFcombined_nucleotides[$y],"\t",$letter_genotypes[$counter],"\n";
					$unque_genotypes{$unique_MFcombined_nucleotides[$y]."_".$unique_MFcombined_nucleotides[$x]} = $letter_genotypes[$counter];
					$unque_genotypes{$unique_MFcombined_nucleotides[$x]."_".$unique_MFcombined_nucleotides[$y]} = $letter_genotypes[$counter];
					#print "hello ",$temp[1],"\t",$#unique_MFcombined_nucleotides,"\t",$y,"\t",$x,"\t",$unique_MFcombined_nucleotides[$y],"\t",$unique_MFcombined_nucleotides[$x],"\t",$letter_genotypes[$counter],"\n";
					$counter+=1;
				}
			}	
			# now print out new file with single letter genotypes for each individual
			print OUTFILE $temp[0],"\t",$temp[1],"\t",$temp[2],"\t";
			for ($y = 3 ; $y <= $#temp; $y=$y+2 ) {
				if(($temp[$y] ne ".")&&($temp[$y+1] ne ".")&&($temp[$y] ne "*")&&($temp[$y+1] ne "*")){ # no missing, no deletions
					print OUTFILE $unque_genotypes{$temp[$y]."_".$temp[$y+1]},"\t";
				}
				else{
					print OUTFILE ".\t";
				}
				$counter+=1;
			}
			print OUTFILE "\n";				
		} # end of check that there is at least one genotype in each sex
	} # end of check to see if we are at the first line	
	else{
		print OUTFILE $line,"\n";
	}
} # end while	
close OUTFILE;
```

And this R script calculates the minimum deviance between models with only one site and the model with the interaction between both:
```R
setwd("/Users/Shared/Previously Relocated Items/Security/projects/2021_XT_sex_linked_markers/2022_WGS/parsetab_epistasis")
options(scipen=999)
# make sure to remove hash (#) from beginning of first line with "CHROM" 
dat <-read.table("Chr7_7Mb_to_12Mb_oneletter_genotypes_NOMISSING_NODELETIONS_subset_every200.tab",header=T)

# 11111110000002222122 refers to whether or not each individual in the ingroup 
# in the vcf file is (0) male, (1) female, and or (2) skipped

# eight females
# six males

sex_and_missing <- c("1","1","1","1","1","1","1","0","0","0","0","0","0","2","2","2","2","1","2","2")
sexes<-vector()

# get the sexes
for(i in sex_and_missing) {
  if(i != "2"){
    sexes <- c(sexes, i)  
  }
}  

# set up the results df
all_the_data <- data.frame(g1="7000000",
                    g2="7000000",
                    deviance="0");all_the_data

#all_the_data<- all_the_data[-1,]
counter99<-1
library(analyzer)
library(sqldf)
for (x in 1:(dim(dat)[1]-1)) {
#for (x in 1:5000) {
      # set up the dataframe for the regression
      my_df <- data.frame(g1=rep("NA",length(sexes)),
                      g2=rep("NA",length(sexes)),
                      sex=sexes);my_df
  
      # populate the g1 column
      counter<-1 # this is used to keep track of rows of my_df df
      for(i in 4:dim(dat)[2]){
        if(sex_and_missing[i-3] != "2"){
          my_df[counter,1] <- dat[x,i]
          counter <- counter + 1
        }
      }
      # now populate the g2 column
      for (y in (x+1):dim(dat)[1]){
         print(paste(x,y))
      #for (y in (x+1):5000){
        counter<-1 # this is used to keep track of rows of my_df df
        for(i in 4:dim(dat)[2]){
          if(sex_and_missing[i-3] != "2"){
            my_df[counter,2] <- dat[y,i]
            counter <- counter + 1
          }
        }
        # calculate the p value of the interaction term and save
        # first check if there is variation in both columns
        if((length(unique(my_df$g1))>1) & (length(unique(my_df$g2))>1)){
          #my_df$g1 <- as.factor(my_df$g1)
          #my_df$g2 <- as.factor(my_df$g2)
          my_df$sex <- as.numeric(my_df$sex)
          # before fitting the model, test for singularities
          # this is when a genotype at the g1 locus is present in only one sex
          # and the interaction with the other locus on sex thus cannot be calculated
          if(
              identical(
                as.vector(sort(na.omit(unlist(as.vector(unique(subset(my_df,sex=="1",select=c("g1")))))))),
                as.vector(sort(na.omit(unlist(as.vector(unique(subset(my_df,sex=="0",select=c("g1"))))))))
              ) &
              (length(na.omit(unlist(as.vector(unique(subset(my_df,sex=="1",select=c("g2"))))))) > 1) &
              (length(na.omit(unlist(as.vector(unique(subset(my_df,sex=="0",select=c("g2"))))))) > 1)
          ){
            m1 <- glm(sex ~ g1, data=my_df, family=binomial())
            m2 <- glm(sex ~ g2, data=my_df, family=binomial())
            mf <- glm(sex ~ g1*g2, data=my_df, family=binomial())
            deviance <- min(anova(m1, mf)$Deviance[2], anova(m2, mf)$Deviance[2])
            
            # only save the ones that are highly correlated, 
            # otherwise the results will be way too bif
            #if((summary(mod)$adj.r.squared > 0.8)|(summary(mod)$adj.r.squared < -0.8)){
            if(deviance > 4){
              print(paste(x,y,dat[x,2],dat[y,2]))
              all_the_data[counter99,1] <- dat[x,2]
              all_the_data[counter99,2] <- dat[y,2]
              all_the_data[counter99,3] <- deviance
              counter99 <- counter99 +1
            }
          }
        }
      }
}

library(ggplot2)
all_the_data$g1 <- as.numeric(all_the_data$g1)
all_the_data$g2 <- as.numeric(all_the_data$g2)
all_the_data$deviance <- as.numeric(all_the_data$deviance)
all_the_data$color <- "red"
all_the_data$color[all_the_data$deviance < 10] <- "blue"
all_the_data$color[all_the_data$deviance < 8] <- "lightblue"
all_the_data$color[all_the_data$deviance < 6] <- "yellow"

heat <- ggplot(all_the_data, aes(x=g1, y=g2, fill=deviance))+
  geom_tile(fill=deviance, colour=all_the_data$color, size=1) +
  theme_classic() +
  #scale_fill_manual(values = c("darkblue", "blue", "lightblue", "white")) +
  theme(legend.position="none")

png(filename = "Datasubset1_heatmap.png",w=800, h=800,units = "px", bg="transparent")
    heat
dev.off()
```
